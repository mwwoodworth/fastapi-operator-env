-- Additional schema for memory records and vector search
-- Auto-generated by Codex

-- Memory records table
CREATE TABLE IF NOT EXISTS memory_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(50) NOT NULL,
    category VARCHAR(50),
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    summary TEXT,
    embedding vector(1536),
    context JSONB DEFAULT '{}'::jsonb,
    tags TEXT[] DEFAULT '{}',
    related_records UUID[] DEFAULT '{}',
    parent_id UUID,
    importance_score FLOAT DEFAULT 0.5,
    access_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    version INTEGER DEFAULT 1
);

-- Document chunks table for RAG
CREATE TABLE IF NOT EXISTS document_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL,
    chunk_index INTEGER NOT NULL,
    text TEXT NOT NULL,
    start_char INTEGER NOT NULL,
    end_char INTEGER NOT NULL,
    document_title TEXT NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    document_metadata JSONB DEFAULT '{}'::jsonb,
    embedding vector(1536),
    tokens INTEGER,
    overlap_prev INTEGER DEFAULT 0,
    overlap_next INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Knowledge entries table
CREATE TABLE IF NOT EXISTS knowledge_entries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    category VARCHAR(50) NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    body TEXT NOT NULL,
    structured_data JSONB,
    examples JSONB DEFAULT '[]'::jsonb,
    references TEXT[] DEFAULT '{}',
    validated BOOLEAN DEFAULT FALSE,
    validation_date TIMESTAMP WITH TIME ZONE,
    quality_score FLOAT DEFAULT 0.0,
    usage_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMP WITH TIME ZONE,
    version VARCHAR(20) DEFAULT '1.0.0',
    previous_versions UUID[] DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Estimate records table
CREATE TABLE IF NOT EXISTS estimate_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_name TEXT NOT NULL,
    building_type VARCHAR(100) NOT NULL,
    roof_area_sf FLOAT NOT NULL,
    roof_type VARCHAR(50) NOT NULL,
    system_type VARCHAR(50) NOT NULL,
    material_cost FLOAT NOT NULL,
    labor_cost FLOAT NOT NULL,
    total_cost FLOAT NOT NULL,
    cost_per_sf FLOAT NOT NULL,
    margin_percentage FLOAT NOT NULL,
    scope_items TEXT[] DEFAULT '{}',
    special_conditions TEXT[] DEFAULT '{}',
    warranty_years INTEGER NOT NULL,
    location TEXT NOT NULL,
    estimate_date TIMESTAMP WITH TIME ZONE NOT NULL,
    valid_until TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) DEFAULT 'draft',
    won_project BOOLEAN,
    actual_cost FLOAT,
    embedding vector(1536),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Documents metadata table
CREATE TABLE IF NOT EXISTS documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    category VARCHAR(50) NOT NULL,
    content_hash VARCHAR(64) NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Retrieval sessions table for analytics
CREATE TABLE IF NOT EXISTS retrieval_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(255),
    task_id VARCHAR(255),
    query TEXT NOT NULL,
    query_embedding vector(1536),
    filters JSONB DEFAULT '{}'::jsonb,
    retrieved_records UUID[] DEFAULT '{}',
    relevance_scores FLOAT[] DEFAULT '{}',
    retrieval_time_ms INTEGER,
    reranking_applied BOOLEAN DEFAULT FALSE,
    selected_records UUID[] DEFAULT '{}',
    feedback_score FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_memory_type ON memory_records(type);
CREATE INDEX IF NOT EXISTS idx_memory_category ON memory_records(category);
CREATE INDEX IF NOT EXISTS idx_memory_tags ON memory_records USING GIN(tags);
CREATE INDEX IF NOT EXISTS idx_memory_created ON memory_records(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memory_embedding ON memory_records USING ivfflat(embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_chunks_document ON document_chunks(document_id);
CREATE INDEX IF NOT EXISTS idx_chunks_embedding ON document_chunks USING ivfflat(embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_knowledge_category ON knowledge_entries(category);
CREATE INDEX IF NOT EXISTS idx_knowledge_validated ON knowledge_entries(validated);

CREATE INDEX IF NOT EXISTS idx_estimates_project ON estimate_records(project_name);
CREATE INDEX IF NOT EXISTS idx_estimates_status ON estimate_records(status);
CREATE INDEX IF NOT EXISTS idx_estimates_embedding ON estimate_records USING ivfflat(embedding vector_cosine_ops);

-- Vector search functions
CREATE OR REPLACE FUNCTION search_memory_records(
    query_embedding vector(1536),
    match_threshold FLOAT,
    match_count INT
) RETURNS TABLE (
    id UUID,
    type VARCHAR,
    category VARCHAR,
    title TEXT,
    content TEXT,
    summary TEXT,
    context JSONB,
    tags TEXT[],
    importance_score FLOAT,
    created_at TIMESTAMP WITH TIME ZONE,
    similarity FLOAT
) LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id,
        m.type,
        m.category,
        m.title,
        m.content,
        m.summary,
        m.context,
        m.tags,
        m.importance_score,
        m.created_at,
        1 - (m.embedding <=> query_embedding) AS similarity
    FROM memory_records m
    WHERE 1 - (m.embedding <=> query_embedding) > match_threshold
    ORDER BY m.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION search_document_chunks(
    query_embedding vector(1536),
    match_threshold FLOAT,
    match_count INT
) RETURNS TABLE (
    id UUID,
    document_id UUID,
    document_title TEXT,
    document_type VARCHAR,
    text TEXT,
    document_metadata JSONB,
    category VARCHAR,
    similarity FLOAT
) LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.document_id,
        c.document_title,
        c.document_type,
        c.text,
        c.document_metadata,
        d.category,
        1 - (c.embedding <=> query_embedding) AS similarity
    FROM document_chunks c
    JOIN documents d ON d.id = c.document_id
    WHERE 1 - (c.embedding <=> query_embedding) > match_threshold
    ORDER BY c.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION increment_memory_access_count(memory_id UUID) RETURNS VOID LANGUAGE plpgsql AS $$
BEGIN
    UPDATE memory_records
    SET access_count = access_count + 1,
        updated_at = NOW()
    WHERE id = memory_id;
END;
$$;

CREATE OR REPLACE FUNCTION check_pgvector_extension() RETURNS BOOLEAN LANGUAGE plpgsql AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'vector'
    );
END;
$$;

